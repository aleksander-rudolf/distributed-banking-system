package server_k;

import Errors.*;

import java.io.IOException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.sql.SQLException;
import java.util.Dictionary;
import java.util.Hashtable;

public class LockManager {
    //#region Class Variables
    private static LockManager instance = null;
    private static Dictionary<String, Lock> accountLocks = new Hashtable<String, Lock>();
    private static Dictionary<String, String> transactionLocks = new Hashtable<String, String>();
    private DBController db = null;
    private final Object lock = new Object();
    private boolean isConnecting = false;
    
    SocketHandler socketHandler = null, socketHandler2 = null, socketHandlerRead = null;
    //#endregion Class Variables

    //#region Constructors & Instance Methods
    /**
     * Constructor
     * @implNote This constructor is private to ensure that only one instance of this class is created.
     */
    private LockManager() {
        try {
            this.socketHandler = new SocketHandler("144.217.92.18", 2026);
            this.socketHandler2 = new SocketHandler("144.217.92.18", 2025);
            this.socketHandlerRead = new SocketHandler("localhost", 2028);
            this.db = DBController.getInstance();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Returns the instance of this class.
     * @return LockManager The instance of this class.
     */
    public static LockManager getInstance() {
        if (instance == null) { instance = new LockManager(); }
        return instance;
    }

    /**
     * Resets the instance of this class.
     * @implNote This method is primarily used for testing purposes.
     */
    public static void resetInstance() {
        instance = null;
    }
    //#endregion Constructors & Instance Methods
    
    //#region Lock Methods
    /**
     * This method is used to lock an account.
     * @param account The account number.
     * @param type The type of lock (transaction -> deposit, withdraw, transfer, etc.)
     * @param randomNumber Random number generated by the client.
     * @return boolean Returns true if the account is successfully locked, false otherwise.
     */
    public synchronized boolean lock(String account, String type, String randomNumber) throws DuplicateTransactionError {
        if (isLocked(account, type)) { return false; }
        if (isPreviousTransaction(account, randomNumber)) { throw new DuplicateTransactionError(); }

        this.socketHandler.send("L " + account + " " + type + " " + randomNumber);
        this.socketHandler2.send("L " + account + " " + type + " " + randomNumber);

        Boolean response_1 = false, response_2 = false;

        // Read reponse from server 1
        try {
            String response = this.socketHandler.read();
            response_1 = Boolean.parseBoolean(response);
        } catch (SocketTimeoutException | SocketException e) {
            response_1 = true;
            System.out.println("SocketException(): Socket Handler #1 has timed out due to a unresponsive master server.");
            attemptSocketReconnection(this.socketHandler);
		} catch (IOException e) {
			System.out.println("IOException(): Socket Handler #1: " + e.getStackTrace());
		}

        // Read response from server 2
        try {
			String response = this.socketHandler2.read();
            response_2 = Boolean.parseBoolean(response);
        } catch (SocketTimeoutException | SocketException e) {
            response_2 = true;
            System.out.println("SocketException(): Socket Handler #2 has timed out due to a unresponsive master server.");
            attemptSocketReconnection(this.socketHandler2);
		} catch (IOException e) {
			System.out.println("IOException(): Socket Handler #2: " + e.getStackTrace());
		}

        if (response_1 && response_2) {
            if (isLocked(account, type)) { return false; }
            accountLocks.put(account, new Lock(type));
            transactionLocks.put(account, randomNumber);

            return true;
        } 

        return false;
    }

    /**
     * This method attempts to lock the account locally.
     * @param account The account number.
     * @param type The type of lock (transaction -> deposit, withdraw, transfer, etc.)
     * @param randomNumber Random number generated by the client.
     * @return boolean Returns true if the account is successfully locked, false otherwise. 
     */
    public synchronized boolean lockLocally(String account, String type, String randomNumber) throws DuplicateTransactionError {
        System.out.println("Server is being requested to lock account #" + account + " locally, with type: " + type);
        if (isLocked(account, type)) { return false; }
        if (isPreviousTransaction(account, randomNumber)) { throw new DuplicateTransactionError(); }

        accountLocks.put(account, new Lock(type));
        transactionLocks.put(account, randomNumber);

        return true;
    }
    //#endregion Lock Methods

    //#region Unlock Methods
    /**
     * This method is used to unlock an account.
     * @param xid The user's ID.
     * @param account The account number.
     * @param type The type of lock (transaction -> deposit, withdraw, transfer, etc.)
     * @param amount The amount of money involved in the transaction.
     * @param result The result of the transaction.
     * @return String The result of the transaction.
     */
    public synchronized String unlock(String xid, String account, String type, double amount, String result) {
        String accounts[] = account.split(",");
        String MajorityBalance = new String();
        // If type is transfer, check both accounts are locked. If not, check if the account is locked
        if (!type.equals("T")) {
            if (!isLocked(account, type)) { return "false"; } // If the account is not locked, then return false.
            if (!accountLocks.get(account).getType().equals(type)) { return "false"; }  // If the lock is not of the same type, then return false.
        } else {
            if (!isLocked(accounts[0], type) || !isLocked(accounts[1], type)) { return "false"; } // If the account is not locked, then return false.
            if (!accountLocks.get(accounts[0]).getType().equals(type) || !accountLocks.get(accounts[1]).getType().equals(type)) { return "false"; }  
        }    

        // Inform the other servers to unlock the account.
        this.socketHandler.send("U " + xid + " " + account + " " + type + " " + amount);
        this.socketHandler2.send("U " + xid + " " + account + " " + type + " " + amount);

        Boolean response_1 = false, response_2 = false;
        Double amountFrom1 = null, amountFrom2 = null;
        Double amountTo1 = null, amountTo2 = null;
        try {
            String answer = this.socketHandler.read();
            String[] answerTokens = answer.split(" ");
            response_1 = Boolean.parseBoolean(answerTokens[0]);

            if (!type.equals("T")) {
                amountFrom1 = Double.parseDouble(answerTokens[1]);
            } else {
                amountFrom1 = Double.parseDouble(answerTokens[1]);
                amountTo1 = Double.parseDouble(answerTokens[2]);
            }
        } catch (SocketTimeoutException | SocketException e) {
            response_1 = true;
            System.out.println("Socket Handler #1 has timed out due to a unrespnsive master server: " + e.getStackTrace());
            attemptSocketReconnection(this.socketHandler);
        } catch (IOException e) {
            System.out.println("Socket Handler #1 has received an IOException: " + e.getStackTrace());
        }

        try {
            String answer = this.socketHandler2.read();
            String[] answerTokens = answer.split(" ");
            response_2 = Boolean.parseBoolean(answerTokens[0]);

            if (!type.equals("T")) {
                amountFrom2 = Double.parseDouble(answerTokens[1]); 
            } else {
                amountFrom2 = Double.parseDouble(answerTokens[1]);
                amountTo2 = Double.parseDouble(answerTokens[2]);
            }  
        } catch (SocketTimeoutException | SocketException e) {
            response_2 = true;
            System.out.println("Socket Handler #1 has timed out due to a unrespnsive master server: " + e.getStackTrace());
            attemptSocketReconnection(this.socketHandler2);
        } catch (IOException e) {
            System.out.println("Socket Handler #1 has received an IOException: " + e.getStackTrace());
        }

        if (!type.equals("T")) {
            MajorityBalance = Double.toString(synchronizeAccounts(xid, amountFrom1, amountFrom2, Double.parseDouble(result), account));
        } else {
            String[] results = result.split(" ");
            MajorityBalance = Double.toString(synchronizeAccounts(xid, amountFrom1, amountFrom2, Double.parseDouble(results[0]), accounts[0]));
            synchronizeAccounts(xid, amountTo1, amountTo2, Double.parseDouble(results[1]), accounts[1]);
        }

        if (response_1 && response_2) {
            if (!type.equals("T")) {
                accountLocks.remove(account);
            } else {
                accountLocks.remove(accounts[0]);
                accountLocks.remove(accounts[1]);
            }

            return "true " + MajorityBalance;
        } 

        return "false";
    }
    
    /**
     * This method attempts to unlock the account locally.
     * @param account The account number.
     * @param type The type of lock (transaction -> deposit, withdraw, transfer, etc.)
     * @return boolean Returns true if the account is successfully unlocked, false otherwise.
     */
	public synchronized boolean unlockLocally(String account, String type) {
        System.out.println("Server is being requested to unlock account #" + account + " locally, with type: " + type);
        if (!isLocked(account, type)) { return false; } // If the account is not locked, then return false.
        if (!accountLocks.get(account).getType().equals(type)) { return false; } // If the lock is not of the same type, then return false.

        accountLocks.remove(account);

        return true;
    }
    //#endregion Unlock Methods

    //#region Misc Methods
    /**
     * This method is used to check if an account is locked.
     * @param account The account number.
     * @param type The type of lock (transaction -> deposit, withdraw, transfer, etc.)
     * @return boolean Returns true if the account is locked, false otherwise.
     */
    public synchronized boolean isLocked(String account, String type) {
        return accountLocks.get(account) == null ? false : true;
    }

    /**
     * This method is used to check if a transaction is a previous transaction.
     * @param account The account number.
     * @param id The transaction id.
     * @return boolean Returns true if the transaction is a previous transaction, false otherwise.
     */
    public synchronized boolean isPreviousTransaction(String account, String id) {
        return transactionLocks.get(account) == null ? false : transactionLocks.get(account).equals(id);
    }

    /**
     * This method is used to attempt to reconnect to another server that has gone down.
     * @param socketHandler The socket handler that we are attempting to reconnect to.
     */
    public void attemptSocketReconnection(SocketHandler socketHandler) {
        synchronized (lock) {
            if (isConnecting) { return; } // If we are already attempting to reconnect, then return.
            isConnecting = true;
        }

        new Thread(() -> {
            while (true) { // Keep trying to reconnect to the master server until we succeed.
                try {
                    socketHandler.reconnect();
                    System.out.println("attemptSocketReconnection(): Reconnected to master server on port " + socketHandler.getPort());
                    
                    String dumpData = db.createDatabaseDump();
                    Thread.sleep(2000);
                    socketHandler.send(dumpData);
                    break;
                } catch (SocketTimeoutException e) {
                    try {
                        System.out.println("SocketTimeoutException(): Timeout due to unresponsive master server on port " + socketHandler.getPort() + ". Retrying in 5 seconds...");
                        Thread.sleep(5000);
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                } catch (IOException e) {
                    try {
                        System.out.println("IOException(): Timeout due to unresponsive master server on port " + socketHandler.getPort() + ". Retrying in 5 seconds...");
						Thread.sleep(5000);
					} catch (InterruptedException e1) {
						e1.printStackTrace();
					}
                } catch (InterruptedException e) {
					e.printStackTrace();
				} catch (SQLException e) {
					e.printStackTrace();
				}
            }
            synchronized (lock) { // We are no longer attempting to reconnect.
                isConnecting = false;
            }
        }).start(); // Start the thread.
    }

    /**
     * This method will synchronize the accounts between the servers, if the majority number is not the same as the result of the transaction, then the account will be updated.
     * @param xid The user's ID.
     * @param amount1 The result of the transaction that was performed on another server.
     * @param amount2 The result of the transaction that was performed on another server.
     * @param result The result of the transaction that was performed on this server.
     * @param account The account number.
     * @return Double The majority number.
     */
    private Double synchronizeAccounts(String xid, Double amount1, Double amount2, double result, String account) {
        Double majorityEl = null;

		try {
            majorityEl = findMajorityNumber(result, amount1, amount2);
            System.out.println("Majority number is: " + majorityEl);

            this.socketHandlerRead.send("X " + account + " " + majorityEl);

            if (amount1 != null && Double.compare(amount1, majorityEl) != 0) {
                this.socketHandler.send("C " + account + " " + majorityEl);
            }

            if (amount2 != null && Double.compare(amount2, majorityEl) != 0) {
                this.socketHandler2.send("C " + account + " " + majorityEl);
            }

            if (Double.compare(result, majorityEl) != 0) {
                try {
                    db.overwriteAccount(account, majorityEl);
                } catch (InvalidError IE) {
                    System.out.println("Error in synchronizeAccounts: " + IE.getStackTrace());
                } catch (SQLException SE) {
                    System.out.println("Error in synchronizeAccounts: " + SE.getStackTrace());
                }
            }

            System.out.println("All accounts synchronized with new balance $" + majorityEl); 
        } catch (NumberFormatException e) {
            System.out.println("Error in synchronizeAccounts: " + e.getStackTrace());
        } 

        return majorityEl;
	}
    
    /**
     * This method is used to find the majority number from 3 given numbers. If all three numbers are different, then the first number is returned.
     * @param num1 The first number used to determine the majority number.
     * @param num2 The second number used to determine the majority number.
     * @param num3 The third number used to determine the majority number.
     * @return Double Returns the majority number.
     */
    private Double findMajorityNumber(Double num1, Double num2, Double num3) {
        if (num3 == null || num2 == null) { return num1; } // Handle the case where one of the numbers is null.
        if (!num1.equals(num2) && !num1.equals(num3) && !num2.equals(num3)) { return num1; } // If all three numbers are different, then return the first number.
        
        // Handle the case where two of the numbers are the same
        if (num1.equals(num2) || num1.equals(num3)) {
            return num1;
        } else if (num2.equals(num3)) {
            return num2;
        }
        
        return null;
    }

    /**
     * This method synchronizes the user's registration with the other servers.
     * @param id The user's ID.
     * @param username The user's username.
     * @param password The user's password.
     * @param firstName The user's first name.
     * @param lastName The user's last name.
     * @param email The user's email.
     * @param accountNumber The account number.
     */
    public void registrationSync(int id, String username, String password, String firstName, String lastName, String email, String accountNumber) {
        if (this.socketHandler != null) {
            this.socketHandler.send("R " + id + " " + username + " " + password + " " + firstName + " " + lastName + " " + email + " " + accountNumber);
        }

        if (this.socketHandler2 != null) {
            this.socketHandler2.send("R " + id + " " + username + " " + password + " " + firstName + " " + lastName + " " + email + " " + accountNumber);
        }
    }
    //#endregion Misc Methods
}